# 大家说-店铺点评平台

项目时间：2022-9 ~ 2022-10

## 概述

这是为区域内店铺提供的一款点评平台，提供了用户点评，点赞，店铺查询，好友关注，优惠券购买及秒杀等功能

## 技术选型

前端：``Nginx`` ``Vue``
后端：``springBoot`` ``MySQL Redis``  ``MyBatis-puls``

## 总体架构

前后端分离：前端部署在nginx上，后端主要是springBoot做MVC三层架构，MyBatis_puls API做持久层，业务层,自定义控制层。

## 数据库设计

基本表：

1. 店铺信息表 
2. 店铺类型表
3. 用户信息表
4. 优惠券表  优惠券基本信息
5. 秒杀优惠券表  依赖于优惠劵表，会有库存和开始，结束时间限制
6. 订单表

设计思路：优惠券是以店铺为一个维度出售，分为通用劵和秒杀劵，通用劵其实也是通用劵，但是有秒杀优惠券表做了限制，限制其库存和开始结束时间

## 功能模块实现

### 1. 手机号登录

总体思路 

  1. 用户输入手机号，获取验证码，后台生成验证码保存并发送给用户
  2. 用户输入验证码，后台接收并对比，
     1. 如果一致，则查询用户是否需要注册，需要则先保存数据库
     2. 不一致，登录失败
  3. 后台生成token ， 保存到redis并返回给前端，前端每次访问都需要在请求头携带token，用于做登录检验

### 2. 登录状态检验

实现思路：通过对用户的请求进行拦截，实现两个拦截器 (实现HandlerInterceptor,实现WebMvcConfigurer的addInterceptors方法添加拦截器)

1. 状态刷新拦截器：所有请求都会被拦截，负责刷新用户token过期时间
2. 登录状态拦截器：对于需要登录的页面会被拦截

具体流程：前端请求携带token，拦截器拦截获取请求头中的token，以其为key请求redis获取user信息，如果user信息不为空，保存用户信息到ThreadLocal（提供了一个全局变量theradloacl），以便下次使用到用户信息使用。如果为空立即返回true，不会执行此拦截器接下来的内容，交给登录拦截器来处理，登录拦截器会在threadlocal中获取用户信息，获取成功则放行，不成功则拦截返回401未授权

### 3. 商铺缓存

#### 更新策略：

1. 超时剔除 设置超时时间
2. 主动更新  
3. 内存淘汰 redis自动淘汰

低一致需求：比如店铺类型信息，内存淘汰
高一致需求：比如店铺详情信息，主动更新加超时剔除兜底

主动更新，在操作数据库的同时操作缓存，缓存更新采用更新数据库时删除缓存的策略，查询数据库的时候再更新缓存，避免写操作多，多做很多无用更新缓存操作。因为写操作时间大于读操作，我们先操作数据库，再删除缓存

#### 业务逻辑

1. 根据id查询店铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间
2. 根据id修改店铺时，先修改数据库，再删除缓存

先修改数据库再删除缓存其中的原理，比如说面试官很可能会追问：“**在写数据的过程中，可以先删除 cache ，后更新 db 么？**”

**答案：** 那肯定是不行的！因为这样可能会造成 数据库（db）和缓存（Cache）数据不一致的问题。

举例：请求 1 先写数据 A，请求 2 随后读数据 A 的话，就很有可能产生数据不一致性的问题。

这个过程可以简单描述为：

> 请求 1 先把 cache 中的 A 数据删除 -> 请求 2 从 db 中读取数据->请求 1 再把 db 中的 A 数据更新

面试官可能会紧接着就追问：“**在写数据的过程中，先更新 db，后删除 cache 就没有问题了么？**”

**答案：** 理论上来说还是可能会出现数据不一致性的问题，不过概率非常小，因为缓存的写入速度是比数据库的写入速度快很多。

举例：请求 1 先读数据 A，请求 2 随后写数据 A，并且数据 A 在请求 1 请求之前不在缓存中的话，也有可能产生数据不一致性的问题。

这个过程可以简单描述为：

> 请求 1 从 db 读数据 A-> 请求 2 更新 db 中的数据 A（此时缓存中无数据 A ，故不用执行删除缓存操作 ） -> 请求 1 将数据 A 写入 cache


tips：缓存店铺信息使用的是Redis的Hash数据类型，也可以使用String+Json。hash适合数据结构比较复杂，经常更新对象字段的情况，而String+Json适合数据结构简单，经常更新一整个对象的情况，因为只需要执行一次操作，但String明显的一个缺点是需要进行json序列化成字符串进行存入和取出


#### 缓存中的问题

1. 缓存穿透：用户请求大量缓存和数据库都不存在的数据，对数据库造成压力
   1. 缓存空对象
   2. 布隆过滤 会在查询缓存时先做预查询
2. 缓存雪崩：大量缓存同时过期
   1. 设置随机的缓存过期时间
   2. 缓存集群
3. 缓存击穿：热点key问题，热点缓存实现，重建缓存时间久，对数据库产生压力
   1. 互斥锁 实现简单，一致性，没有额外消耗，但性能低
      1. 缓存失效，获取锁进行缓存重建，没有获取到锁的线程自旋获取，sleep（1秒）
   2. 逻辑过期 性能高，额外消耗，实现复杂，数据不一致
      1. 使用RedisDTO对象进行转化，有两个字段数据date和过期时间datetime，在存入时连同datetime一起储存，取出时转化为redisdate，把其中的datetime与现在进行比较是否过期，过期则获取锁，开启新线程进行缓存重建，然后返回过期数据，没有获取到锁的线程返回也返回过期数据


### 4. 达人探店

#### 博客发布及查看

1. 发布blog：对象接收前端传过来的数据，前端没有传入userId，我们查询ThreadLocal找到当前用户id，设置进blog字段里，并保存。
2. 查看blog：根据blogId查询blog，再根据blog中的UserId并将User的头像信息，昵称，当前用户是否点赞的信息设置进去，这三个字段，在实体类中设置为@TableField(exist = false)，意为在数据库里是不存在的字段，这样做的好处是方便了一些，不用再新建一个DTO类。判断当前用户是否点赞是查询redis中的Zset对应Key的字段的score是否不为空，不为空则存在


#### 点赞及点赞排行

1. 点赞：前端只会传入一个blogid，我们再根据ThreadLocal的Userid，从redis的zset中查询用户是否点赞过，没有则操作数据库点赞数加一，且保存userid到相应blogid的redis的zset中。反之则点赞数减一，删除redis中的userid。
2. 排行榜，点赞往redis的Key为blogid的Zset中放入score值为当前日期时间戳的userid。排行榜只需要获得zset里score前五的数据，zset默认是升序，且左闭右开，java命令rang，命令行zrang；获得点赞该blog的前五条用户id，再遍历id查询数据库，获得数据放入UserDTO中，返回给前端。

### 5. 关注和共同好友，推送feed流

1. 关注：数据库表采用userId和followId两个字段，点击博客详情会查看当前用户是否已关注该博主，关注则添加数据，取关则删除数据
2. 共同关注：在把关注关系存入数据库时，把数据再放一份到redis的set中，博主用户为key，value是当前useId，使用redis的sinter命令，java整合的intersect命令
3. 推送feed流：在发布blog时，会查询粉丝列表，会把blogid发送到粉丝的收信箱中，收信箱实现是redis的zset集合，粉丝的userid为key，vlue是blogid，scoer是blog的发布时间戳；粉丝在线时会查询自己的收件箱，进行滚动分页查询已关注博主的博客。
4. 滚动分页查询：将上次查询的最小值作为下次查询的数据的最大值,同时注意,偏移量.偏移量的求法为,求得上次所有数据中和最小的score相等的数量,同时注意 offset = 0表示和最大值小于等于.包含等于，第一次查询max为当前时间戳，zset默认排序升序，我们取出时是取反操作，从现在往前取

### 6. 优惠券秒杀

#### 1. 数据库设计

两种表：  

1. 优惠卷表：普通优惠卷，拥有一些优惠券基本信息，还有是否是秒杀劵的标识
2. 优惠秒杀劵表： 首先秒杀劵也是普通优惠卷，只是多了一些特殊字段，比如开始，结束时间，还有库存

#### 2. 全局ID生成器

几种策略：

1. 数据库自增
   1. 依赖数据库，不同的表自增起点不同
2. UUID
   1. 无法保证有序自增
3. redis
   1. 依赖redis
4. 雪花算法
   1. 依赖机器时钟

最终选定redis实现  
使用javaLong生成，64bit位。第一个bit为符号位（永远为0），后31个为时间戳（大约可用60多年），再后是redis的incr命令自增产生的32个为序列号（java命令为opsForValue.increment()大约每秒可产生2的32次方的序列号）。

时间戳与序列号拼接技巧：时间戳向左移32位，然后按位或计算

```java
 public long nextId(String keyPrefix) {
        //1.生成时间戳
        LocalDateTime now = LocalDateTime.now();
        long nowSecond = now.toEpochSecond(ZoneOffset.UTC);
        long timeStamp = nowSecond - BEGIN_TIMESTAMP;

        //2.生成序列号
        //2.1 获取今天年月日
        String date = now.format(DateTimeFormatter.ofPattern("yyyy:MM:dd"));
        //2.2 设置Redis自增
        Long count = stringRedisTemplate.opsForValue().increment("icr:" + keyPrefix + ":" + date);

        //3.拼接并返回
        return timeStamp << BEGIN_BITS | count;
    }
```

#### 3. 秒杀下单

思路：判断用户是否具有购买条件（起始时间，库存），然后可以购买的话，做向order表添加一条订单数据，并扣减库存且返回订单编号。  
其中涉及到的表操作

  1. seckill_voucher表的根据id查询操作
  2. seckill_voucher表的根据id修改剩余数量的操作
  3. voucher_order表的新增订单数据操作  
     涉及到多表操作需要添加事务，同成功，同失败

#### 4. 超卖问题

问题说明：多线程并发下，一个线程查询库存为1，在未扣减库存前，另一线程查询库存也为1，后续流程下来导致两线程都进行了扣减，导致库存出现负数的异常现象。

问题解决思路：通过扣减库存时进行加锁解决多线程并发问题，有乐观锁和悲观锁两种，采用乐观锁，在更改库存时，判断现在库存是否与之前所查相同，相同证明为被其他线程修改，课更改库存。但是这样经过测试，用200个线程去买一百张劵，只成功20多张；发现原因对于库存来说，并不需要和之前相同才能成功，只需要库存大于零就可以购买，所以条件改为库存大于0就可以成功扣减库存

```java
// 6.扣减库存
            boolean success = seckillVoucherService.update()
                    .setSql("stock = stock - 1") // set stock = stock - 1
                    .eq("voucher_id", voucherId).gt("stock", 0) // where id = ? and stock > 0
                    .update();
            if (!success) {
                // 扣减失败
                log.error("库存不足！");
                return;
            }
```

#### 5. 一人一单

问题说明：同一个优惠卷一人只能下一单，防止黄牛批量刷券

> tip: @Transational只能使用在public方法上，因为底层是通过CGLib（继承）来实现AOP管理。如果要支持非public可以开启AspectJ代理模式（接口方式）。

解决思路思路：通过在扣减库存前判断该人是否已经下过订单，在多线程情况下会发生并发问题：a线程查询数据库订单不存在，在还没创建订单时，b线程也查询了数据库，发现订单也没创建，这时就会出现两次订单创建。所以可以在查询数据库订单创建时获取锁，以实现并发安全。

#### 6. 分步式锁  

问题说明：单机项目的锁，是jvm实现的，集群环境下，多个jvm的锁是不相同的，所以会导致锁失效。

1. 基于数据库实现分布式锁：
   1. 优点：实现简单，数据库资源充足，不需要额外中间件。
   2. 缺点：性能较低，这种方式实现分布式锁时不可重入的，没有容错等待。
2. 基于缓存(Redis等)实现分布式锁：
   1. 优点：速度快，简单实现。
   2. 缺点：Redis宕机无法释放锁，其他失败无法等待，需要进行演变升级。
3. 基于Zookeeper实现分布式锁：
   1. 优点：功能强大，机制可以保证分布式锁的实现。
   2. 缺点：需要额外的中间件，系统复杂度高。

最终通过Redsion实现了分步式锁。

> Redsion分步式锁: 待建设

#### 7. 秒杀优化

问题说明：查询










​      
